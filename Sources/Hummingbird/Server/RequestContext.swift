//===----------------------------------------------------------------------===//
//
// This source file is part of the Hummingbird server framework project
//
// Copyright (c) 2021-2022 the Hummingbird authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See hummingbird/CONTRIBUTORS.txt for the list of Hummingbird authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

import Logging

/// Context that created HBRequest.
public protocol HBRequestContext: Sendable {
    /// EventLoop request is running on
    var eventLoop: EventLoop { get }
    /// ByteBuffer allocator used by request
    var allocator: ByteBufferAllocator { get }
    /// Connected host address
    var remoteAddress: SocketAddress? { get }
    /// reference to application
    var applicationContext: HBApplication.Context { get }
    var logger: Logger { get }
    var requestId: String { get }
    /// Endpoint path. This is stored a var so it can be edited by the router. In theory this could
    /// be accessed on multiple thread/tasks at the same point but it is only ever edited by router
    var endpointPath: String? { get nonmutating set }
}

extension HBRequestContext {
    public var logger: Logger {
        applicationContext.logger.with(metadataKey: "hb_id", value: .stringConvertible(requestId))
    }

    /// Return failed `EventLoopFuture`
    public func failure<T>(_ error: Error) -> EventLoopFuture<T> {
        return self.eventLoop.makeFailedFuture(error)
    }

    /// Return failed `EventLoopFuture` with http response status code
    public func failure<T>(_ status: HTTPResponseStatus) -> EventLoopFuture<T> {
        return self.eventLoop.makeFailedFuture(HBHTTPError(status))
    }

    /// Return failed `EventLoopFuture` with http response status code and message
    public func failure<T>(_ status: HTTPResponseStatus, message: String) -> EventLoopFuture<T> {
        return self.eventLoop.makeFailedFuture(HBHTTPError(status, message: message))
    }

    /// Return succeeded `EventLoopFuture`
    public func success<T>(_ value: T) -> EventLoopFuture<T> {
        return self.eventLoop.makeSucceededFuture(value)
    }

    // Return new version of request with collated request body. If you want to process the
    // request body in middleware you need to call this to ensure you have the full request
    // body. Once this is called the request generated by this should be passed to the nextResponder
    public func collateBody(of request: HBRequest) -> EventLoopFuture<HBRequest> {
        request.body.consumeBody(
            maxSize: self.applicationContext.configuration.maxUploadSize,
            on: self.eventLoop
        ).flatMapThrowing { buffer in
            var request = request
            request.body = .byteBuffer(buffer)
            return request
        }
    }

    // Return new version of request with collated request body. If you want to process the
    // request body in middleware you need to call this to ensure you have the full request
    // body. Once this is called the request generated by this should be passed to the nextResponder
    public func collateBody(of request: HBRequest, maxSize: Int) -> EventLoopFuture<HBRequest> {
        request.body.consumeBody(maxSize: maxSize, on: self.eventLoop).flatMapThrowing { buffer in
            var request = request
            request.body = .byteBuffer(buffer)
            return request
        }
    }
}